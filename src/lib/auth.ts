import bcryptjs from 'bcryptjs'
import jwt from 'jsonwebtoken'
import { PrismaClient, User, Session } from '@prisma/client'

const prisma = new PrismaClient()

const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-here'
const SESSION_EXPIRY_DAYS = 30

// –¢–∏–ø—ã –¥–ª—è –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
export interface AuthUser {
  id: string
  email: string
  firstName: string
  lastName: string
  role: string
  verified: boolean
}

export interface LoginResult {
  success: boolean
  user?: AuthUser
  token?: string
  message: string
}

export interface RegisterResult {
  success: boolean
  user?: AuthUser
  message: string
}

// –•–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è
export async function hashPassword(password: string): Promise<string> {
  const saltRounds = 12
  return bcryptjs.hash(password, saltRounds)
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è
export async function verifyPassword(password: string, hashedPassword: string): Promise<boolean> {
  return bcryptjs.compare(password, hashedPassword)
}

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è JWT —Ç–æ–∫–µ–Ω–∞
export function generateJWTToken(userId: string, email: string, role: string): string {
  return jwt.sign(
    { userId, email, role },
    JWT_SECRET,
    { expiresIn: `${SESSION_EXPIRY_DAYS}d` }
  )
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ JWT —Ç–æ–∫–µ–Ω–∞
export function verifyJWTToken(token: string): { userId: string; email: string; role: string } | null {
  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any
    return {
      userId: decoded.userId,
      email: decoded.email,
      role: decoded.role
    }
  } catch (error) {
    return null
  }
}

// –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function createUserSession(
  userId: string, 
  userAgent?: string, 
  ipAddress?: string
): Promise<Session> {
  // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è —Ç–æ–∫–µ–Ω–∞
  const user = await prisma.user.findUnique({
    where: { id: userId }
  })

  if (!user) {
    throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω')
  }

  const token = generateJWTToken(userId, user.email, user.role)
  const expiresAt = new Date()
  expiresAt.setDate(expiresAt.getDate() + SESSION_EXPIRY_DAYS)

  return prisma.session.create({
    data: {
      userId,
      token,
      expiresAt,
      userAgent,
      ipAddress
    }
  })
}

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Å—Å–∏–∏
export async function verifySession(token: string): Promise<Session | null> {
  const session = await prisma.session.findFirst({
    where: {
      token,
      expiresAt: {
        gt: new Date()
      }
    }
  })

  return session
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ —Ç–æ–∫–µ–Ω—É
export async function getUserFromToken(token: string): Promise<AuthUser | null> {
  const session = await verifySession(token)
  if (!session) return null

  // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ—Ç–¥–µ–ª—å–Ω–æ
  const user = await prisma.user.findUnique({
    where: { id: session.userId }
  })

  if (!user) return null

  return {
    id: user.id,
    email: user.email,
    firstName: user.firstName,
    lastName: user.lastName,
    role: user.role,
    verified: user.verified
  }
}

// –î–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏
export async function deactivateSession(token: string): Promise<void> {
  await prisma.session.deleteMany({
    where: { token }
  })
}

// –û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö —Å–µ—Å—Å–∏–π
export async function cleanupExpiredSessions(): Promise<void> {
  await prisma.session.deleteMany({
    where: {
      expiresAt: {
        lt: new Date()
      }
    }
  })
}

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function registerUser(
  email: string,
  password: string,
  firstName: string,
  lastName: string,
  phone?: string
): Promise<RegisterResult> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const existingUser = await prisma.user.findUnique({
      where: { email }
    })

    if (existingUser) {
      return {
        success: false,
        message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
      }
    }

    // –•–µ—à–∏—Ä—É–µ–º –ø–∞—Ä–æ–ª—å
    const hashedPassword = await hashPassword(password)

    // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.create({
      data: {
        email,
        password: hashedPassword,
        firstName,
        lastName,
        phone
      }
    })

    const authUser: AuthUser = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      verified: user.verified
    }

    return {
      success: true,
      user: authUser,
      message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω'
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error)
    return {
      success: false,
      message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'
    }
  }
}

// –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function loginUser(
  email: string,
  password: string,
  userAgent?: string,
  ipAddress?: string
): Promise<LoginResult> {
  try {
    console.log('üîç –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', email)
    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { email }
    })

    if (!user) {
      console.log('‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω')
      return {
        success: false,
        message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
      }
    }

    console.log('‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å')

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
    const isValidPassword = await verifyPassword(password, user.password)
    console.log('üîë –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è:', isValidPassword ? '—É—Å–ø–µ—à–Ω–æ' : '–Ω–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å')
    
    if (!isValidPassword) {
      return {
        success: false,
        message: '–ù–µ–≤–µ—Ä–Ω—ã–π email –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
      }
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∞–∫—Ç–∏–≤–µ–Ω –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å (–µ—Å–ª–∏ –∫–æ–ª–æ–Ω–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
    console.log('üë§ –°—Ç–∞—Ç—É—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', { verified: user.verified })
    // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É active, —Ç–∞–∫ –∫–∞–∫ –∫–æ–ª–æ–Ω–∫–∞ –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å –≤ –ø—Ä–æ–¥–∞–∫—à–Ω –ë–î

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ lastLogin —É–±—Ä–∞–Ω–æ, —Ç–∞–∫ –∫–∞–∫ –∫–æ–ª–æ–Ω–∫–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –ø—Ä–æ–¥–∞–∫—à–Ω –ë–î

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–æ—Å—Ç–æ–π JWT —Ç–æ–∫–µ–Ω –±–µ–∑ —Å–µ—Å—Å–∏–∏
    const token = generateJWTToken(user.id, user.email, user.role)
    console.log('‚úÖ JWT —Ç–æ–∫–µ–Ω —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω')

    const authUser: AuthUser = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      verified: user.verified
    }

    return {
      success: true,
      user: authUser,
      token: token,
      message: '–£—Å–ø–µ—à–Ω—ã–π –≤—Ö–æ–¥'
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏:', error)
    console.error('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', {
      name: error instanceof Error ? error.name : 'Unknown',
      message: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined
    })
    return {
      success: false,
      message: '–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏'
    }
  }
}

// –í—ã—Ö–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function logoutUser(token: string): Promise<boolean> {
  try {
    await deactivateSession(token)
    return true
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error)
    return false
  }
}

// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
export async function getCurrentUser(token: string): Promise<AuthUser | null> {
  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º JWT —Ç–æ–∫–µ–Ω
    const decoded = verifyJWTToken(token)
    if (!decoded) {
      return null
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ –±–∞–∑—ã
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId }
    })

    if (!user) {
      return null
    }

    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      verified: user.verified
    }
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', error)
    return null
  }
}

// –û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–±–µ–∑ –ø–∞—Ä–æ–ª—è)
export function sanitizeUser(user: User): Omit<User, 'password'> {
  const { password, ...sanitizedUser } = user
  return sanitizedUser
}